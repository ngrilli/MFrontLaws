/*!
* \file   TFEL/Material/CrystalPlasticityDislocationUpdate.hxx
* \brief  this file implements the CrystalPlasticityDislocationUpdate Behaviour.
*         File generated by tfel version 3.4.0
* \author Nicolò Grilli
* \date   17 / 08 / 2023
 */

#ifndef LIB_TFELMATERIAL_CRYSTALPLASTICITYDISLOCATIONUPDATE_HXX
#define LIB_TFELMATERIAL_CRYSTALPLASTICITYDISLOCATIONUPDATE_HXX

#include<string>
#include<iostream>
#include<limits>
#include<stdexcept>
#include<algorithm>

#include"TFEL/Raise.hxx"
#include"TFEL/PhysicalConstants.hxx"
#include"TFEL/Config/TFELConfig.hxx"
#include"TFEL/Config/TFELTypes.hxx"
#include"TFEL/Metaprogramming/StaticAssert.hxx"
#include"TFEL/TypeTraits/IsFundamentalNumericType.hxx"
#include"TFEL/TypeTraits/IsReal.hxx"
#include"TFEL/Math/General/IEEE754.hxx"
#include"TFEL/Material/MaterialException.hxx"
#include"TFEL/Material/MechanicalBehaviour.hxx"
#include"TFEL/Material/MechanicalBehaviourTraits.hxx"
#include"TFEL/Material/OutOfBoundsPolicy.hxx"
#include"TFEL/Material/BoundsCheck.hxx"
#include"TFEL/Material/IsotropicPlasticity.hxx"
#include"TFEL/Material/Lame.hxx"
#include"TFEL/Material/Hosford1972YieldCriterion.hxx"
#include"TFEL/Material/OrthotropicPlasticity.hxx"
#include"TFEL/Material/OrthotropicStressLinearTransformation.hxx"
#include"TFEL/Material/Hill.hxx"
#include"TFEL/Material/Barlat2004YieldCriterion.hxx"
#include"TFEL/Material/OrthotropicAxesConvention.hxx"
#include"TFEL/Material/StiffnessTensor.hxx"
#include"TFEL/Material/CrystalPlasticityDislocationUpdateBehaviourData.hxx"
#include"TFEL/Material/CrystalPlasticityDislocationUpdateIntegrationData.hxx"

#include"TFEL/Math/st2tost2.hxx"
#include"TFEL/Math/tmatrix.hxx"
#include"TFEL/Math/tvector.hxx"
#include"TFEL/Math/Matrix/tmatrixIO.hxx"
#include"TFEL/Math/Vector/tvectorIO.hxx"
#include"TFEL/Math/ST2toST2/ST2toST2ConceptIO.hxx"
#include"TFEL/Math/Vector/TinyVectorFromTinyVectorView.hxx"
#include"TFEL/Math/Vector/TinyVectorFromTinyVectorViewIO.hxx"
#include"TFEL/Math/Stensor/StensorFromTinyVectorView.hxx"
#include "TFEL/Math/Stensor/StensorFromTinyMatrixRowView.hxx"
#include "TFEL/Math/Stensor/StensorFromTinyMatrixRowView2.hxx"
#include"TFEL/Math/ST2toST2/ST2toST2FromTinyMatrixView.hxx"

#include"TFEL/Math/ST2toST2/ST2toST2FromTinyMatrixView2.hxx"

#include"TFEL/Math/Stensor/StensorFromTinyMatrixColumnView.hxx"
#include"TFEL/Math/Stensor/StensorFromTinyMatrixRowView.hxx"
#include"TFEL/Math/Stensor/StensorFromTinyMatrixColumnView2.hxx"
#include"TFEL/Math/Stensor/StensorFromTinyMatrixRowView2.hxx"
#include"TFEL/Math/Vector/TinyVectorOfStensorFromTinyVectorView.hxx"
#include"TFEL/Math/Vector/TinyVectorOfStensorFromTinyVectorViewIO.hxx"
#include"TFEL/Math/General/CubicRoots.hxx"
#include "TFEL/Material/CrystalPlasticityDislocationUpdateSlipSystems.hxx"

#include"MFront/Aster/Aster.hxx"

namespace tfel{

namespace material{

struct CrystalPlasticityDislocationUpdateTridimensionalParametersInitializer
{
static CrystalPlasticityDislocationUpdateTridimensionalParametersInitializer&
get();


void set(const char* const,const double);

void set(const char* const,const unsigned short);

private :

CrystalPlasticityDislocationUpdateTridimensionalParametersInitializer();

CrystalPlasticityDislocationUpdateTridimensionalParametersInitializer(const CrystalPlasticityDislocationUpdateTridimensionalParametersInitializer&);

CrystalPlasticityDislocationUpdateTridimensionalParametersInitializer&
operator=(const CrystalPlasticityDislocationUpdateTridimensionalParametersInitializer&);
/*!
 * \brief read the parameters from the given file
 * \param[out] pi : parameters initializer
 * \param[in]  fn : file name
 */
static void readParameters(CrystalPlasticityDislocationUpdateTridimensionalParametersInitializer&,const char* const);
};

struct CrystalPlasticityDislocationUpdateParametersInitializer
{
static CrystalPlasticityDislocationUpdateParametersInitializer&
get();

double epsilon;
double theta;
double young1;
double young2;
double young3;
double nu12;
double nu23;
double nu13;
double mu12;
double mu23;
double mu13;
double ao;
double xm;
double creep_ao;
double creep_xm;
double burgers_vector_mag;
double shear_modulus;
double alpha_0;
double r;
double tau_c_0;
double k_0;
double y_c;
double h;
double h_D;
double init_rho_ssd;
double minimal_time_step_scaling_factor;
double maximal_time_step_scaling_factor;
double numerical_jacobian_epsilon;
unsigned short iterMax;

void set(const char* const,const double);

void set(const char* const,const unsigned short);

/*!
 * \brief convert a string to double
 * \param[in] p : parameter
 * \param[in] v : value
 */
static double getDouble(const std::string&,const std::string&);
/*!
 * \brief convert a string to unsigned short
 * \param[in] p : parameter
 * \param[in] v : value
 */
static unsigned short getUnsignedShort(const std::string&,const std::string&);
private :

CrystalPlasticityDislocationUpdateParametersInitializer();

CrystalPlasticityDislocationUpdateParametersInitializer(const CrystalPlasticityDislocationUpdateParametersInitializer&);

CrystalPlasticityDislocationUpdateParametersInitializer&
operator=(const CrystalPlasticityDislocationUpdateParametersInitializer&);
/*!
 * \brief read the parameters from the given file
 * \param[out] pi : parameters initializer
 * \param[in]  fn : file name
 */
static void readParameters(CrystalPlasticityDislocationUpdateParametersInitializer&,const char* const);
};

//! \brief forward declaration
template<ModellingHypothesis::Hypothesis,typename Type,bool use_qt>
class CrystalPlasticityDislocationUpdate;

//! \brief forward declaration
template<ModellingHypothesis::Hypothesis hypothesis,typename Type>
std::ostream&
 operator <<(std::ostream&,const CrystalPlasticityDislocationUpdate<hypothesis,Type,false>&);

//! \brief forward declaration
template<typename Type>
std::ostream&
 operator <<(std::ostream&,const CrystalPlasticityDislocationUpdate<ModellingHypothesis::TRIDIMENSIONAL,Type,false>&);

/*!
* \class CrystalPlasticityDislocationUpdate
* \brief This class implements the CrystalPlasticityDislocationUpdate behaviour.
* \param hypothesis, modelling hypothesis.
* \param Type, numerical type.
* \author Nicolò Grilli
* \date   17 / 08 / 2023
* The MFront version of the dislocation density evolution model 
* based on dislocation multiplication and annihilation 
* with Armstrong - Frederick backstress evolution . 
* The model parameters are calibrated for 316 H stainless steel at 550 C 
* Original source code here : 
* https : 
*/
template<typename Type>
class CrystalPlasticityDislocationUpdate<ModellingHypothesis::TRIDIMENSIONAL,Type,false> final
: public MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,ModellingHypothesis::TRIDIMENSIONAL,Type,false>,
public CrystalPlasticityDislocationUpdateBehaviourData<ModellingHypothesis::TRIDIMENSIONAL,Type,false>,
public CrystalPlasticityDislocationUpdateIntegrationData<ModellingHypothesis::TRIDIMENSIONAL,Type,false>{

static constexpr ModellingHypothesis::Hypothesis hypothesis = ModellingHypothesis::TRIDIMENSIONAL;
static constexpr unsigned short N = ModellingHypothesisToSpaceDimension<hypothesis>::value;

TFEL_STATIC_ASSERT(N==1||N==2||N==3);
TFEL_STATIC_ASSERT(tfel::typetraits::IsFundamentalNumericType<Type>::cond);
TFEL_STATIC_ASSERT(tfel::typetraits::IsReal<Type>::cond);

friend std::ostream& operator<< <>(std::ostream&,const CrystalPlasticityDislocationUpdate&);

static constexpr unsigned short TVectorSize = N;
typedef tfel::math::StensorDimeToSize<N> StensorDimeToSize;
static constexpr unsigned short StensorSize = StensorDimeToSize::value;
typedef tfel::math::TensorDimeToSize<N> TensorDimeToSize;
static constexpr unsigned short TensorSize = TensorDimeToSize::value;

using ushort =  unsigned short;
using Types = tfel::config::Types<N,Type,false>;
using real                = typename Types::real;
using time                = typename Types::time;
using length              = typename Types::length;
using frequency           = typename Types::frequency;
using stress              = typename Types::stress;
using strain              = typename Types::strain;
using strainrate          = typename Types::strainrate;
using stressrate          = typename Types::stressrate;
using temperature         = typename Types::temperature;
using thermalexpansion    = typename Types::thermalexpansion;
using thermalconductivity = typename Types::thermalconductivity;
using massdensity         = typename Types::massdensity;
using energydensity         = typename Types::energydensity;
using TVector             = typename Types::TVector;
using Stensor             = typename Types::Stensor;
using Stensor4            = typename Types::Stensor4;
using FrequencyStensor    = typename Types::FrequencyStensor;
using ForceTVector        = typename Types::ForceTVector;
using StressStensor       = typename Types::StressStensor;
using StressRateStensor   = typename Types::StressRateStensor;
using DisplacementTVector = typename Types::DisplacementTVector;
using StrainStensor       = typename Types::StrainStensor;
using StrainRateStensor   = typename Types::StrainRateStensor;
using StiffnessTensor     = typename Types::StiffnessTensor;
using Tensor              = typename Types::Tensor;
using FrequencyTensor     = typename Types::FrequencyTensor;
using StressTensor        = typename Types::StressTensor;
using ThermalExpansionCoefficientTensor = typename Types::ThermalExpansionCoefficientTensor;
using DeformationGradientTensor         = typename Types::DeformationGradientTensor;
using DeformationGradientRateTensor     = typename Types::DeformationGradientRateTensor;
using TemperatureGradient = typename Types::TemperatureGradient;
using HeatFlux = typename Types::HeatFlux;
using TangentOperator   = FiniteStrainBehaviourTangentOperator<N,stress>;
using PhysicalConstants = tfel::PhysicalConstants<real>;

public :

typedef CrystalPlasticityDislocationUpdateBehaviourData<hypothesis,Type,false> BehaviourData;
typedef CrystalPlasticityDislocationUpdateIntegrationData<hypothesis,Type,false> IntegrationData;
typedef typename MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis,Type,false>::SMFlag SMFlag;
typedef typename MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis,Type,false>::SMType SMType;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis,Type,false>::ELASTIC;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis,Type,false>::SECANTOPERATOR;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis,Type,false>::TANGENTOPERATOR;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis,Type,false>::CONSISTENTTANGENTOPERATOR;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis,Type,false>::NOSTIFFNESSREQUESTED;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis,Type,false>::DSIG_DF;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis,Type,false>::DSIG_DDF;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis,Type,false>::C_TRUESDELL;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis,Type,false>::SPATIAL_MODULI;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis,Type,false>::C_TAU_JAUMANN;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis,Type,false>::ABAQUS;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis,Type,false>::DSIG_DDE;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis,Type,false>::DTAU_DF;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis,Type,false>::DTAU_DDF;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis,Type,false>::DS_DF;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis,Type,false>::DS_DDF;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis,Type,false>::DS_DC;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis,Type,false>::DS_DEGL;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis,Type,false>::DT_DELOG;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis,Type,false>::DPK1_DF;
using IntegrationResult = typename MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis,Type,false>::IntegrationResult;

using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis,Type,false>::SUCCESS;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis,Type,false>::FAILURE;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis,Type,false>::UNRELIABLE_RESULTS;

using StressFreeExpansionType = StrainStensor;

private :

static constexpr int Nss0 = 12;
static constexpr int Nss = 12;

StrainStensor eel;

typename tfel::math::StensorFromTinyVectorView<N,12+StensorSize,0,real>::type deel;
typename tfel::math::TinyVectorFromTinyVectorView<12,12+StensorSize,StensorSize,real,false>::type dg;

struct{
DeformationGradientTensor dF;
DeformationGradientTensor Fe_tr;
DeformationGradientTensor Fe0;
StressStensor S;
Tensor inv_dFp;
real J_inv_dFp;
StrainStensor tmp;
} fsscb_data;
StiffnessTensor D;
StiffnessTensor& D_tdt;

real epsilon;
real theta;
real young1;
real young2;
real young3;
real nu12;
real nu23;
real nu13;
real mu12;
real mu23;
real mu13;
#line 44 "CrystalPlasticityDislocationUpdate.mfront"
real ao;
#line 45 "CrystalPlasticityDislocationUpdate.mfront"
real xm;
#line 46 "CrystalPlasticityDislocationUpdate.mfront"
real creep_ao;
#line 47 "CrystalPlasticityDislocationUpdate.mfront"
real creep_xm;
#line 48 "CrystalPlasticityDislocationUpdate.mfront"
real burgers_vector_mag;
#line 49 "CrystalPlasticityDislocationUpdate.mfront"
real shear_modulus;
#line 50 "CrystalPlasticityDislocationUpdate.mfront"
real alpha_0;
#line 51 "CrystalPlasticityDislocationUpdate.mfront"
real r;
#line 52 "CrystalPlasticityDislocationUpdate.mfront"
real tau_c_0;
#line 53 "CrystalPlasticityDislocationUpdate.mfront"
real k_0;
#line 54 "CrystalPlasticityDislocationUpdate.mfront"
real y_c;
#line 55 "CrystalPlasticityDislocationUpdate.mfront"
real h;
#line 56 "CrystalPlasticityDislocationUpdate.mfront"
real h_D;
#line 57 "CrystalPlasticityDislocationUpdate.mfront"
real init_rho_ssd;
real minimal_time_step_scaling_factor;
real maximal_time_step_scaling_factor;
real numerical_jacobian_epsilon;
ushort iterMax;

//! Tangent operator;
TangentOperator Dt;
// updating material properties, in mandatory
void updateMaterialPropertiesDependantOnStateVariables(){
using namespace std;
using namespace tfel::math;
using std::vector;
}

/*!
 * \return the part of the jacobian matrix corresponding to the derivative of variable eel by variable g
 */
typename tfel::math::StensorFromTinyMatrixColumnView2<N,12+StensorSize,12+StensorSize,0,StensorSize,real>::type
dfeel_ddg(tfel::math::tmatrix<12+StensorSize,12+StensorSize,real>& tjacobian,
const unsigned short idx){
using namespace tfel::math;
return typename StensorFromTinyMatrixColumnView2<N,12+StensorSize,12+StensorSize,0,StensorSize,real>::type(tjacobian,0,idx);
}

typename tfel::math::StensorFromTinyMatrixColumnView2<N,12+StensorSize,12+StensorSize,0,StensorSize,real>::type
dfeel_ddg(const unsigned short idx){
using namespace tfel::math;
return typename StensorFromTinyMatrixColumnView2<N,12+StensorSize,12+StensorSize,0,StensorSize,real>::type(this->jacobian,0,idx);
}

/*!
 * \return the part of the jacobian matrix corresponding to the derivative of variable g by variable eel
 */
typename tfel::math::StensorFromTinyMatrixRowView2<N,12+StensorSize,12+StensorSize,StensorSize,0,real>::type
dfg_ddeel(tfel::math::tmatrix<12+StensorSize,12+StensorSize,real>& tjacobian,
const unsigned short idx){
using namespace tfel::math;
return typename StensorFromTinyMatrixRowView2<N,12+StensorSize,12+StensorSize,StensorSize,0,real>::type(tjacobian,idx,0);
}

typename tfel::math::StensorFromTinyMatrixRowView2<N,12+StensorSize,12+StensorSize,StensorSize,0,real>::type
dfg_ddeel(const unsigned short idx){
using namespace tfel::math;
return typename StensorFromTinyMatrixRowView2<N,12+StensorSize,12+StensorSize,StensorSize,0,real>::type(this->jacobian,idx,0);
}

/*!
 * \return the part of the jacobian matrix corresponding to the derivative of variable g by variable g
 */
real&
dfg_ddg(tfel::math::tmatrix<12+StensorSize,12+StensorSize,real>& tjacobian,
const unsigned short idx, const unsigned short idx2){
return tjacobian(StensorSize+idx, StensorSize+idx2);
}

real&
dfg_ddg(const unsigned short idx, const unsigned short idx2){
return this->jacobian(StensorSize+idx, StensorSize+idx2);
}

// Jacobian
tfel::math::tmatrix<12+StensorSize,12+StensorSize,real> jacobian;
// zeros
tfel::math::tvector<12+StensorSize,real> zeros;

// previous zeros
tfel::math::tvector<12+StensorSize,real> zeros_1;

// function
tfel::math::tvector<12+StensorSize,real> fzeros;

// number of iterations
unsigned int iter = 0u;

void computeNumericalJacobian(tfel::math::tmatrix<12+StensorSize,12+StensorSize,real>& njacobian)
{
using namespace std;
using namespace tfel::math;
tvector<12+StensorSize,real> tzeros(this->zeros);
tvector<12+StensorSize,real> tfzeros(this->fzeros);
tmatrix<12+StensorSize,12+StensorSize,real> tjacobian(this->jacobian);
for(unsigned short idx = 0; idx!= 12+StensorSize;++idx){
this->zeros(idx) -= this->numerical_jacobian_epsilon;
this->computeFdF(true);
this->zeros = tzeros;
tvector<12+StensorSize,real> tfzeros2(this->fzeros);
this->zeros(idx) += this->numerical_jacobian_epsilon;
this->computeFdF(true);
this->fzeros = (this->fzeros-tfzeros2)/(2*(this->numerical_jacobian_epsilon));
for(unsigned short idx2 = 0; idx2!= 12+StensorSize;++idx2){
njacobian(idx2,idx) = this->fzeros(idx2);
}
this->zeros    = tzeros;
this->fzeros   = tfzeros;
}
if(&njacobian!=&(this->jacobian)){
this->jacobian = tjacobian;
}
}

void
computePartialJacobianInvert(const tfel::math::TinyPermutation<12+StensorSize>& jacobian_permutation, tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel)
{
using namespace tfel::math;
for(unsigned short idx=0;idx!=StensorSize;++idx){
tvector<12+StensorSize,real> vect_e(real(0));
vect_e(idx) = real(1);
TinyMatrixSolve<12+StensorSize,real>::back_substitute(this->jacobian,jacobian_permutation,vect_e);
for(unsigned short idx2=0;idx2!=StensorSize;++idx2){
partial_jacobian_eel(idx2,idx)=vect_e(idx2);
}
}
}

void
computePartialJacobianInvert(const tfel::math::TinyPermutation<12+StensorSize>& jacobian_permutation, tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::tvector<12, tfel::math::derivative_type<strain, StrainStensor>>& partial_jacobian_g)
{
using namespace tfel::math;
for(unsigned short idx=0;idx!=StensorSize;++idx){
tvector<12+StensorSize,real> vect_e(real(0));
vect_e(idx) = real(1);
TinyMatrixSolve<12+StensorSize,real>::back_substitute(this->jacobian,jacobian_permutation,vect_e);
for(unsigned short idx2=0;idx2!=StensorSize;++idx2){
partial_jacobian_eel(idx2,idx)=vect_e(idx2);
}
for(unsigned short idx2=0;idx2!=12;++idx2){
partial_jacobian_g(idx2)(idx)=vect_e(StensorSize+idx2);
}
}
}

void additionalConvergenceChecks(bool&,real&,const SMType) const{
} // end of additionalConvergenceChecks

void computeFinalThermodynamicForces(){
using namespace std;
using namespace tfel::math;
using std::vector;
const auto& ss = CrystalPlasticityDislocationUpdateSlipSystems<real>::getSlidingSystems();
this->fsscb_data.inv_dFp = Tensor::Id();
for(unsigned short i=0;i!=CrystalPlasticityDislocationUpdateSlipSystems<real>::Nss;++i){
  this->fsscb_data.inv_dFp -= dg[i]*ss.mu[i];
}
this->fsscb_data.J_inv_dFp = det(this->fsscb_data.inv_dFp);
this->fsscb_data.inv_dFp /= CubicRoots::cbrt(this->fsscb_data.J_inv_dFp);
this->Fe = (this->fsscb_data.Fe_tr)*(this->fsscb_data.inv_dFp);
this->fsscb_data.S = (this->D)*(this->eel);
this->sig = convertSecondPiolaKirchhoffStressToCauchyStress(this->fsscb_data.S,this->Fe);

} // end of CrystalPlasticityDislocationUpdate::computeFinalThermodynamicForces

/*!
* \brief Update internal variables at end of integration
*/
void updateIntegrationVariables(){
this->eel += this->deel;
}

/*!
* \brief Update internal variables at end of integration
*/
void updateStateVariables(){
this->g += this->dg;
}

/*!
* \brief Update auxiliary state variables at end of integration
*/
void updateAuxiliaryStateVariables(){
using namespace std;
using namespace tfel::math;
#line 153 "CrystalPlasticityDislocationUpdate.mfront"
using size_type = unsigned short;
#line 154 "CrystalPlasticityDislocationUpdate.mfront"
for (size_type i = 0; i != CrystalPlasticityDislocationUpdate::Nss; ++i) {
#line 156 "CrystalPlasticityDislocationUpdate.mfront"
this->p[i] += abs(this->dg[i]);
#line 158 "CrystalPlasticityDislocationUpdate.mfront"
this->delta_rho_ssd[i] += (this->k_0 * std::sqrt(this->init_rho_ssd + this->delta_rho_ssd[i]) - 2.0 * this->y_c * (this->init_rho_ssd + this->delta_rho_ssd[i])) * abs(this->dg[i]) / this->burgers_vector_mag;
#line 160 "CrystalPlasticityDislocationUpdate.mfront"
}
}

//! \brief Default constructor (disabled)
CrystalPlasticityDislocationUpdate() =delete ;
//! \brief Copy constructor (disabled)
CrystalPlasticityDislocationUpdate(const CrystalPlasticityDislocationUpdate&) = delete;
//! \brief Assignement operator (disabled)
CrystalPlasticityDislocationUpdate& operator = (const CrystalPlasticityDislocationUpdate&) = delete;

public:

/*!
* \brief Constructor
*/
CrystalPlasticityDislocationUpdate(const CrystalPlasticityDislocationUpdateBehaviourData<hypothesis,Type,false>& src1,
const CrystalPlasticityDislocationUpdateIntegrationData<hypothesis,Type,false>& src2)
: CrystalPlasticityDislocationUpdateBehaviourData<hypothesis,Type,false>(src1),
CrystalPlasticityDislocationUpdateIntegrationData<hypothesis,Type,false>(src2),
deel(this->zeros),
dg(this->zeros),
D_tdt(D),
zeros(real(0)),
fzeros(real(0))
{
using namespace std;
using namespace tfel::math;
using std::vector;
this->epsilon = CrystalPlasticityDislocationUpdateParametersInitializer::get().epsilon;
this->theta = CrystalPlasticityDislocationUpdateParametersInitializer::get().theta;
this->young1 = CrystalPlasticityDislocationUpdateParametersInitializer::get().young1;
this->young2 = CrystalPlasticityDislocationUpdateParametersInitializer::get().young2;
this->young3 = CrystalPlasticityDislocationUpdateParametersInitializer::get().young3;
this->nu12 = CrystalPlasticityDislocationUpdateParametersInitializer::get().nu12;
this->nu23 = CrystalPlasticityDislocationUpdateParametersInitializer::get().nu23;
this->nu13 = CrystalPlasticityDislocationUpdateParametersInitializer::get().nu13;
this->mu12 = CrystalPlasticityDislocationUpdateParametersInitializer::get().mu12;
this->mu23 = CrystalPlasticityDislocationUpdateParametersInitializer::get().mu23;
this->mu13 = CrystalPlasticityDislocationUpdateParametersInitializer::get().mu13;
this->ao = CrystalPlasticityDislocationUpdateParametersInitializer::get().ao;
this->xm = CrystalPlasticityDislocationUpdateParametersInitializer::get().xm;
this->creep_ao = CrystalPlasticityDislocationUpdateParametersInitializer::get().creep_ao;
this->creep_xm = CrystalPlasticityDislocationUpdateParametersInitializer::get().creep_xm;
this->burgers_vector_mag = CrystalPlasticityDislocationUpdateParametersInitializer::get().burgers_vector_mag;
this->shear_modulus = CrystalPlasticityDislocationUpdateParametersInitializer::get().shear_modulus;
this->alpha_0 = CrystalPlasticityDislocationUpdateParametersInitializer::get().alpha_0;
this->r = CrystalPlasticityDislocationUpdateParametersInitializer::get().r;
this->tau_c_0 = CrystalPlasticityDislocationUpdateParametersInitializer::get().tau_c_0;
this->k_0 = CrystalPlasticityDislocationUpdateParametersInitializer::get().k_0;
this->y_c = CrystalPlasticityDislocationUpdateParametersInitializer::get().y_c;
this->h = CrystalPlasticityDislocationUpdateParametersInitializer::get().h;
this->h_D = CrystalPlasticityDislocationUpdateParametersInitializer::get().h_D;
this->init_rho_ssd = CrystalPlasticityDislocationUpdateParametersInitializer::get().init_rho_ssd;
this->minimal_time_step_scaling_factor = CrystalPlasticityDislocationUpdateParametersInitializer::get().minimal_time_step_scaling_factor;
this->maximal_time_step_scaling_factor = CrystalPlasticityDislocationUpdateParametersInitializer::get().maximal_time_step_scaling_factor;
this->numerical_jacobian_epsilon = CrystalPlasticityDislocationUpdateParametersInitializer::get().numerical_jacobian_epsilon;
this->iterMax = CrystalPlasticityDislocationUpdateParametersInitializer::get().iterMax;
// updating the stiffness tensor at the middle of the time step
tfel::material::computeOrthotropicStiffnessTensor<hypothesis,StiffnessTensorAlterationCharacteristic::UNALTERED,OrthotropicAxesConvention::DEFAULT>(this->D,this->young1,
this->young2,
this->young3,
this->nu12,
this->nu23,
this->nu13,
this->mu12,
this->mu23,
this->mu13);
}

/*
 * \brief constructor for the Aster interface
 * \param[in] ASTERdt_: time increment
 * \param[in] ASTERT_: temperature
 * \param[in] ASTERdT_: temperature increment
 * \param[in] ASTERmat: material properties
 * \param[in] ASTERint_vars: state variables
 * \param[in] ASTERext_vars: external state variables
 * \param[in] ASTERdext_vars: external state variables increments
 */
CrystalPlasticityDislocationUpdate(const Type* const ASTERdt_,
const Type* const ASTERT_,
const Type* const ASTERdT_,
const Type* const ASTERmat,
const Type* const ASTERint_vars,
const Type* const ASTERext_vars,
const Type* const ASTERdext_vars)
: CrystalPlasticityDislocationUpdateBehaviourData<hypothesis,Type,false>(ASTERT_,ASTERmat,
ASTERint_vars,ASTERext_vars),
CrystalPlasticityDislocationUpdateIntegrationData<hypothesis,Type,false>(ASTERdt_,ASTERdT_,ASTERdext_vars),
deel(this->zeros),
dg(this->zeros),
D_tdt(D),
zeros(real(0)),
fzeros(real(0))
{
using namespace std;
using namespace tfel::math;
using std::vector;
this->epsilon = CrystalPlasticityDislocationUpdateParametersInitializer::get().epsilon;
this->theta = CrystalPlasticityDislocationUpdateParametersInitializer::get().theta;
this->young1 = CrystalPlasticityDislocationUpdateParametersInitializer::get().young1;
this->young2 = CrystalPlasticityDislocationUpdateParametersInitializer::get().young2;
this->young3 = CrystalPlasticityDislocationUpdateParametersInitializer::get().young3;
this->nu12 = CrystalPlasticityDislocationUpdateParametersInitializer::get().nu12;
this->nu23 = CrystalPlasticityDislocationUpdateParametersInitializer::get().nu23;
this->nu13 = CrystalPlasticityDislocationUpdateParametersInitializer::get().nu13;
this->mu12 = CrystalPlasticityDislocationUpdateParametersInitializer::get().mu12;
this->mu23 = CrystalPlasticityDislocationUpdateParametersInitializer::get().mu23;
this->mu13 = CrystalPlasticityDislocationUpdateParametersInitializer::get().mu13;
this->ao = CrystalPlasticityDislocationUpdateParametersInitializer::get().ao;
this->xm = CrystalPlasticityDislocationUpdateParametersInitializer::get().xm;
this->creep_ao = CrystalPlasticityDislocationUpdateParametersInitializer::get().creep_ao;
this->creep_xm = CrystalPlasticityDislocationUpdateParametersInitializer::get().creep_xm;
this->burgers_vector_mag = CrystalPlasticityDislocationUpdateParametersInitializer::get().burgers_vector_mag;
this->shear_modulus = CrystalPlasticityDislocationUpdateParametersInitializer::get().shear_modulus;
this->alpha_0 = CrystalPlasticityDislocationUpdateParametersInitializer::get().alpha_0;
this->r = CrystalPlasticityDislocationUpdateParametersInitializer::get().r;
this->tau_c_0 = CrystalPlasticityDislocationUpdateParametersInitializer::get().tau_c_0;
this->k_0 = CrystalPlasticityDislocationUpdateParametersInitializer::get().k_0;
this->y_c = CrystalPlasticityDislocationUpdateParametersInitializer::get().y_c;
this->h = CrystalPlasticityDislocationUpdateParametersInitializer::get().h;
this->h_D = CrystalPlasticityDislocationUpdateParametersInitializer::get().h_D;
this->init_rho_ssd = CrystalPlasticityDislocationUpdateParametersInitializer::get().init_rho_ssd;
this->minimal_time_step_scaling_factor = CrystalPlasticityDislocationUpdateParametersInitializer::get().minimal_time_step_scaling_factor;
this->maximal_time_step_scaling_factor = CrystalPlasticityDislocationUpdateParametersInitializer::get().maximal_time_step_scaling_factor;
this->numerical_jacobian_epsilon = CrystalPlasticityDislocationUpdateParametersInitializer::get().numerical_jacobian_epsilon;
this->iterMax = CrystalPlasticityDislocationUpdateParametersInitializer::get().iterMax;
// updating the stiffness tensor at the middle of the time step
tfel::material::computeOrthotropicStiffnessTensor<hypothesis,StiffnessTensorAlterationCharacteristic::UNALTERED,OrthotropicAxesConvention::DEFAULT>(this->D,this->young1,
this->young2,
this->young3,
this->nu12,
this->nu23,
this->nu13,
this->mu12,
this->mu23,
this->mu13);
}

/*!
 * \ brief initialize the behaviour with user code
 */
void initialize(){
using namespace std;
using namespace tfel::math;
using std::vector;
this->fsscb_data.dF    = (this->F1)*invert(this->F0);
this->fsscb_data.Fe0   = this->Fe;
this->fsscb_data.Fe_tr = (this->fsscb_data.dF)*(this->fsscb_data.Fe0);
this->eel = computeGreenLagrangeTensor(this->Fe);

}

/*!
* \brief set the policy for "out of bounds" conditions
*/
void
setOutOfBoundsPolicy(const OutOfBoundsPolicy policy_value){
this->policy = policy_value;
} // end of setOutOfBoundsPolicy

/*!
* \return the modelling hypothesis
*/
constexpr ModellingHypothesis::Hypothesis
getModellingHypothesis() const{
return hypothesis;
} // end of getModellingHypothesis

/*!
* \brief check bounds
*/
void checkBounds() const{
} // end of checkBounds

IntegrationResult computePredictionOperator(const SMFlag,const SMType) override{
tfel::raise("CrystalPlasticityDislocationUpdate::computePredictionOperator: "
"unsupported prediction operator flag");
}

real getMinimalTimeStepScalingFactor() const override{
  return this->minimal_time_step_scaling_factor;
}

std::pair<bool,real>
computeAPrioriTimeStepScalingFactor(const real current_time_step_scaling_factor) const override{
const auto time_scaling_factor = this->computeAPrioriTimeStepScalingFactorII();
return {time_scaling_factor.first,
        std::min(std::min(std::max(time_scaling_factor.second,
                                   this->minimal_time_step_scaling_factor),
                          this->maximal_time_step_scaling_factor),
                  current_time_step_scaling_factor)};
}

/*!
 * \brief Integrate behaviour law over the time step
 */
IntegrationResult integrate(const SMFlag smflag,const SMType smt) override{
using namespace std;
using namespace tfel::math;
auto error = real{};
bool converged=false;
this->iter=0;
while((converged==false)&&
(this->iter<CrystalPlasticityDislocationUpdate::iterMax)){
++(this->iter);
const auto computeFdF_ok = this->computeFdF(false);
if(computeFdF_ok){
error=norm(this->fzeros)/(real(12+StensorSize));
}
if((!computeFdF_ok)||(!ieee754::isfinite(error))){
if(this->iter==1){
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis,Type,false>::FAILURE;
} else {
const real integrate_one_half = real(1)/real(2);
this->zeros -= (this->zeros-this->zeros_1)*integrate_one_half;
this->updateMaterialPropertiesDependantOnStateVariables();
}
} else {
this->zeros_1  = this->zeros;
converged = error<this->epsilon;
this->additionalConvergenceChecks(converged, error, smt);
if((!converged)||(smt!=NOSTIFFNESSREQUESTED)){
}
if(!converged){
try{
TinyMatrixSolve<12+StensorSize,real>::exe(this->jacobian,this->fzeros);
}
catch(LUException&){
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis,Type,false>::FAILURE;
}
this->zeros -= this->fzeros;
this->updateMaterialPropertiesDependantOnStateVariables();
}
}
}
if(this->iter==this->iterMax){
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis,Type,false>::FAILURE;
}
this->updateIntegrationVariables();
this->updateStateVariables();
this->computeFinalThermodynamicForces();
this->updateAuxiliaryStateVariables();
if(smt!=NOSTIFFNESSREQUESTED){
if(!this->computeConsistentTangentOperator(smflag,smt)){
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis,Type,false>::FAILURE;
}
}
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis,Type,false>::SUCCESS;
} // end of CrystalPlasticityDislocationUpdate::integrate

/*!
* \brief compute fzeros and jacobian
*/
bool computeFdF(const bool perturbatedSystemEvaluation){
using namespace std;
using namespace tfel::math;
using std::vector;
// silent compiler warning
static_cast<void>(perturbatedSystemEvaluation); 
constexpr const auto eel_offset = 0;
static_cast<void>(eel_offset);
typename tfel::math::StensorFromTinyVectorView<N,12+StensorSize,0,real>::type feel(this->fzeros);
constexpr const auto g_offset = StensorSize;
static_cast<void>(g_offset);
typename tfel::math::TinyVectorFromTinyVectorView<12,12+StensorSize,StensorSize,real,false>::type fg(this->fzeros);
// derivative of variable feel by variable eel
typename tfel::math::ST2toST2FromTinyMatrixView<N,12+StensorSize,12+StensorSize,
0,0,real>::type dfeel_ddeel(this->jacobian);
// setting jacobian to identity
std::fill(this->jacobian.begin(),this->jacobian.end(),real(0));
for(unsigned short idx = 0; idx!=12+StensorSize;++idx){
this->jacobian(idx,idx)= real(1);
}
// setting f values to zeros
this->fzeros = this->zeros;
const auto& ss = CrystalPlasticityDislocationUpdateSlipSystems<real>::getSlidingSystems();
this->fsscb_data.S = (this->D)*(this->eel+this->deel);
this->fsscb_data.tmp = StrainStensor::Id() + 2*(this->eel+this->deel);
// Mandel stress tensor
const auto M = eval(this->fsscb_data.tmp*(this->fsscb_data.S));
// Mandel stress tensor derivative
const auto dM_ddeel = eval(2*st2tot2<N,real>::tpld(this->fsscb_data.S)+
			    st2tot2<N,real>::tprd(this->fsscb_data.tmp,this->D));
this->fsscb_data.inv_dFp = Tensor::Id();
for(unsigned short i=0;i!=CrystalPlasticityDislocationUpdateSlipSystems<real>::Nss;++i){
  this->fsscb_data.inv_dFp -= (this->dg[i])*ss.mu[i];
}
this->fsscb_data.J_inv_dFp = det(this->fsscb_data.inv_dFp);
this->fsscb_data.inv_dFp /= CubicRoots::cbrt(this->fsscb_data.J_inv_dFp);
this->Fe = (this->fsscb_data.Fe_tr)*(this->fsscb_data.inv_dFp);
feel = this->eel+this->deel-computeGreenLagrangeTensor(this->Fe);
const auto fsscb_tprd = t2tot2<N,real>::tprd(this->fsscb_data.Fe_tr);
const auto fsscb_dfeel_dinv_dFp = t2tost2<N,real>::dCdF(this->Fe)*fsscb_tprd;
for(unsigned short i=0;i!=CrystalPlasticityDislocationUpdateSlipSystems<real>::Nss;++i){
  dfeel_ddg(i) = (fsscb_dfeel_dinv_dFp)*ss.mu[i]/2;
}
#line 68 "CrystalPlasticityDislocationUpdate.mfront"
using size_type = unsigned short;
#line 71 "CrystalPlasticityDislocationUpdate.mfront"
const auto& m = ss.him;
#line 74 "CrystalPlasticityDislocationUpdate.mfront"
constexpr const auto eeps = 1.e-12;
#line 75 "CrystalPlasticityDislocationUpdate.mfront"
const auto seps = eeps * (this->D)(0, 0);
#line 78 "CrystalPlasticityDislocationUpdate.mfront"
for (size_type i = 0; i != CrystalPlasticityDislocationUpdate::Nss; ++i) {
#line 81 "CrystalPlasticityDislocationUpdate.mfront"
const auto tau = M | ss.mu[i];
#line 85 "CrystalPlasticityDislocationUpdate.mfront"
auto taylor_hardening = 0.0;
#line 88 "CrystalPlasticityDislocationUpdate.mfront"
const auto effective_stress = abs(tau);
#line 91 "CrystalPlasticityDislocationUpdate.mfront"
auto slip_resistance = (this->tau_c_0);
#line 93 "CrystalPlasticityDislocationUpdate.mfront"
for (size_type j = 0; j != CrystalPlasticityDislocationUpdate::Nss; ++j) {
#line 95 "CrystalPlasticityDislocationUpdate.mfront"
taylor_hardening += m(i,j) * ((this->init_rho_ssd) + (this->delta_rho_ssd)[j]);
#line 97 "CrystalPlasticityDislocationUpdate.mfront"
}
#line 99 "CrystalPlasticityDislocationUpdate.mfront"
slip_resistance += (this->alpha_0) * (this->shear_modulus) * (this->burgers_vector_mag) * std::sqrt(taylor_hardening);
#line 103 "CrystalPlasticityDislocationUpdate.mfront"
auto dslip_resistance_dgammadoti = 0.5 * (this->alpha_0) * (this->shear_modulus) * (this->burgers_vector_mag) / std::sqrt(taylor_hardening);
#line 104 "CrystalPlasticityDislocationUpdate.mfront"
auto drho_ssd_dgammadoti = ((this->k_0) * std::sqrt((this->init_rho_ssd) + (this->delta_rho_ssd)[i]) - 2.0 * (this->y_c) * ((this->init_rho_ssd) + (this->delta_rho_ssd)[i])) / (this->burgers_vector_mag);
#line 105 "CrystalPlasticityDislocationUpdate.mfront"
dslip_resistance_dgammadoti *= m(i,i) * drho_ssd_dgammadoti;
#line 107 "CrystalPlasticityDislocationUpdate.mfront"
auto stress_ratio = effective_stress / slip_resistance;
#line 111 "CrystalPlasticityDislocationUpdate.mfront"
if (stress_ratio > 2) {
#line 112 "CrystalPlasticityDislocationUpdate.mfront"
return false;
#line 113 "CrystalPlasticityDislocationUpdate.mfront"
}
#line 116 "CrystalPlasticityDislocationUpdate.mfront"
const auto sgn = tau > 0 ? 1 : -1;
#line 119 "CrystalPlasticityDislocationUpdate.mfront"
auto n = 1.0 / (this->xm);
#line 122 "CrystalPlasticityDislocationUpdate.mfront"
const auto v = (this->ao) * pow(stress_ratio, n);
#line 123 "CrystalPlasticityDislocationUpdate.mfront"
const auto dv = n * (this->ao) * pow(stress_ratio, n-1) / slip_resistance;
#line 126 "CrystalPlasticityDislocationUpdate.mfront"
fg[i] -= (this->dt) * v * sgn;
#line 129 "CrystalPlasticityDislocationUpdate.mfront"
dfg_ddeel(i) = -(this->dt) * dv * (ss.mu[i] | dM_ddeel);
#line 135 "CrystalPlasticityDislocationUpdate.mfront"
dfg_ddg(i, i) += 0.0;
#line 137 "CrystalPlasticityDislocationUpdate.mfront"
auto dslip_resistance_dgammadotj = 0.5 * (this->alpha_0) * (this->shear_modulus) * (this->burgers_vector_mag) / std::sqrt(taylor_hardening);
#line 139 "CrystalPlasticityDislocationUpdate.mfront"
for (size_type j = 0; j != CrystalPlasticityDislocationUpdate::Nss; ++j) {
#line 141 "CrystalPlasticityDislocationUpdate.mfront"
auto drho_ssd_dgammadotj = ((this->k_0) * std::sqrt((this->init_rho_ssd) + (this->delta_rho_ssd)[j]) - 2.0 * (this->y_c) * ((this->init_rho_ssd) + (this->delta_rho_ssd)[j])) / (this->burgers_vector_mag);
#line 142 "CrystalPlasticityDislocationUpdate.mfront"
dslip_resistance_dgammadotj *= m(i,j) * drho_ssd_dgammadotj;
#line 146 "CrystalPlasticityDislocationUpdate.mfront"
dfg_ddg(i, j) += 0.0;
#line 147 "CrystalPlasticityDislocationUpdate.mfront"
}
#line 148 "CrystalPlasticityDislocationUpdate.mfront"
}
static_cast<void>(dfeel_ddeel); /* suppress potential warnings */
return true;
}

std::pair<bool,real>
computeAPosterioriTimeStepScalingFactor(const real current_time_step_scaling_factor) const override{
const auto time_scaling_factor = this->computeAPosterioriTimeStepScalingFactorII();
return {time_scaling_factor.first,
        std::min(std::min(std::max(time_scaling_factor.second,
                                   this->minimal_time_step_scaling_factor),
                          this->maximal_time_step_scaling_factor),
                 current_time_step_scaling_factor)};
}

/*!
* \brief Update the internal energy at end of the time step
* \param[in] Psi_s: internal energy at end of the time step
*/
void computeInternalEnergy(real& Psi_s) const
{
Psi_s=0;
}

/*!
* \brief Update the dissipated energy at end of the time step
* \param[in] Psi_d: dissipated energy at end of the time step
*/
void computeDissipatedEnergy(real& Psi_d) const
{
Psi_d=0;
}

bool computeConsistentTangentOperator_DSIG_DF(const SMType smt){
using namespace tfel::math;
// computing DTAU_DDF
this->computeConsistentTangentOperator_DTAU_DDF(smt);
const t2tost2<N,stress> tangentOperator_DTAU_DDF = this->Dt.template get<t2tost2<N,stress> >();
const auto tangentOperator_DTAU_DF = convert<DTAU_DF,DTAU_DDF>(tangentOperator_DTAU_DDF,this->F0,this->F1,this->sig);
this->Dt = convert<DSIG_DF,DTAU_DF>(tangentOperator_DTAU_DF,this->F0,this->F1,this->sig);
return true;
}

bool computeConsistentTangentOperator_DSIG_DDF(const SMType smt){
using namespace tfel::math;
// computing DTAU_DDF
this->computeConsistentTangentOperator_DTAU_DDF(smt);
const t2tost2<N,stress> tangentOperator_DTAU_DDF = this->Dt.template get<t2tost2<N,stress> >();
const auto tangentOperator_DTAU_DF = convert<DTAU_DF,DTAU_DDF>(tangentOperator_DTAU_DDF,this->F0,this->F1,this->sig);
const auto tangentOperator_DSIG_DF = convert<DSIG_DF,DTAU_DF>(tangentOperator_DTAU_DF,this->F0,this->F1,this->sig);
this->Dt = convert<DSIG_DDF,DSIG_DF>(tangentOperator_DSIG_DF,this->F0,this->F1,this->sig);
return true;
}

bool computeConsistentTangentOperator_C_TRUESDELL(const SMType smt){
using namespace tfel::math;
// computing DTAU_DDF
this->computeConsistentTangentOperator_DTAU_DDF(smt);
const t2tost2<N,stress> tangentOperator_DTAU_DDF = this->Dt.template get<t2tost2<N,stress> >();
const auto tangentOperator_DTAU_DF = convert<DTAU_DF,DTAU_DDF>(tangentOperator_DTAU_DDF,this->F0,this->F1,this->sig);
const auto tangentOperator_SPATIAL_MODULI = convert<SPATIAL_MODULI,DTAU_DF>(tangentOperator_DTAU_DF,this->F0,this->F1,this->sig);
this->Dt = convert<C_TRUESDELL,SPATIAL_MODULI>(tangentOperator_SPATIAL_MODULI,this->F0,this->F1,this->sig);
return true;
}

bool computeConsistentTangentOperator_SPATIAL_MODULI(const SMType smt){
using namespace tfel::math;
// computing DTAU_DDF
this->computeConsistentTangentOperator_DTAU_DDF(smt);
const t2tost2<N,stress> tangentOperator_DTAU_DDF = this->Dt.template get<t2tost2<N,stress> >();
const auto tangentOperator_DTAU_DF = convert<DTAU_DF,DTAU_DDF>(tangentOperator_DTAU_DDF,this->F0,this->F1,this->sig);
this->Dt = convert<SPATIAL_MODULI,DTAU_DF>(tangentOperator_DTAU_DF,this->F0,this->F1,this->sig);
return true;
}

bool computeConsistentTangentOperator_C_TAU_JAUMANN(const SMType smt){
using namespace tfel::math;
// computing DTAU_DDF
this->computeConsistentTangentOperator_DTAU_DDF(smt);
const t2tost2<N,stress> tangentOperator_DTAU_DDF = this->Dt.template get<t2tost2<N,stress> >();
const auto tangentOperator_DTAU_DF = convert<DTAU_DF,DTAU_DDF>(tangentOperator_DTAU_DDF,this->F0,this->F1,this->sig);
this->Dt = convert<C_TAU_JAUMANN,DTAU_DF>(tangentOperator_DTAU_DF,this->F0,this->F1,this->sig);
return true;
}

bool computeConsistentTangentOperator_ABAQUS(const SMType smt){
using namespace tfel::math;
// computing DTAU_DDF
this->computeConsistentTangentOperator_DTAU_DDF(smt);
const t2tost2<N,stress> tangentOperator_DTAU_DDF = this->Dt.template get<t2tost2<N,stress> >();
const auto tangentOperator_DTAU_DF = convert<DTAU_DF,DTAU_DDF>(tangentOperator_DTAU_DDF,this->F0,this->F1,this->sig);
this->Dt = convert<ABAQUS,DTAU_DF>(tangentOperator_DTAU_DF,this->F0,this->F1,this->sig);
return true;
}

bool computeConsistentTangentOperator_DSIG_DDE(const SMType){
tfel::raise("CrystalPlasticityDislocationUpdate::computeConsistentTangentOperator_DSIG_DDE: "
"computing the tangent operator 'DSIG_DDE' is not supported");
}

bool computeConsistentTangentOperator_DTAU_DF(const SMType smt){
using namespace tfel::math;
// computing DTAU_DDF
this->computeConsistentTangentOperator_DTAU_DDF(smt);
const t2tost2<N,stress> tangentOperator_DTAU_DDF = this->Dt.template get<t2tost2<N,stress> >();
this->Dt = convert<DTAU_DF,DTAU_DDF>(tangentOperator_DTAU_DDF,this->F0,this->F1,this->sig);
return true;
}

bool computeConsistentTangentOperator_DTAU_DDF(const SMType smt){
using namespace std;
using namespace tfel::math;
using std::vector;
TinyPermutation<12+StensorSize> jacobian_permutation;
TinyMatrixSolve<12+StensorSize,real>::decomp(this->jacobian,jacobian_permutation);
struct TFEL_VISIBILITY_LOCAL GetPartialJacobianInvert{
GetPartialJacobianInvert(CrystalPlasticityDislocationUpdate& b,
const tfel::math::TinyPermutation<12+StensorSize>& p)
: behaviour(b),
permutation(p)
{}
void operator()(tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel){
this->behaviour.computePartialJacobianInvert(this->permutation, partial_jacobian_eel);
}
void operator()(tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::tvector<12, tfel::math::derivative_type<strain, StrainStensor>>& partial_jacobian_g){
this->behaviour.computePartialJacobianInvert(this->permutation, partial_jacobian_eel,
partial_jacobian_g);
}
private:
CrystalPlasticityDislocationUpdate& behaviour;
const tfel::math::TinyPermutation<12+StensorSize>& permutation;
}; // end of struct GetPartialJacobianInvert
GetPartialJacobianInvert getPartialJacobianInvert(*this, jacobian_permutation);
static_cast<void>(smt);
const auto& ss = CrystalPlasticityDislocationUpdateSlipSystems<real>::getSlidingSystems();
const auto fsscb_dC_dFe = t2tost2<N,real>::dCdF(this->Fe);
const auto fsscb_dS_dFe = eval((this->D)*fsscb_dC_dFe/2);
const auto fsscb_dtau_dFe = computePushForwardDerivative(fsscb_dS_dFe,this->fsscb_data.S,this->Fe);
const auto fsscb_dFe_dDF_tot = t2tot2<N,real>::tpld(this->fsscb_data.inv_dFp,                     t2tot2<N,real>::tpld(this->fsscb_data.Fe0));
const auto fsscb_dfeel_dDF = eval(-(fsscb_dC_dFe)*(fsscb_dFe_dDF_tot)/2);
st2tost2<N,real> fsscb_Je;
tvector<CrystalPlasticityDislocationUpdateSlipSystems<real>::Nss,Stensor> fsscb_Jg;
getPartialJacobianInvert(fsscb_Je,fsscb_Jg);
t2tot2<N,real> fsscb_dinv_Fp_dDF = (ss.mu[0])^(fsscb_Jg[0]|fsscb_dfeel_dDF);
for(unsigned short i=1;i!=CrystalPlasticityDislocationUpdateSlipSystems<real>::Nss;++i){
  fsscb_dinv_Fp_dDF += (ss.mu[i])^(fsscb_Jg[i]|fsscb_dfeel_dDF);
}
const auto fsscb_dFe_dDF=
  fsscb_dFe_dDF_tot+t2tot2<N,real>::tprd(this->fsscb_data.Fe_tr,fsscb_dinv_Fp_dDF);
Dt = fsscb_dtau_dFe*fsscb_dFe_dDF;

return true;
}

bool computeConsistentTangentOperator_DS_DF(const SMType smt){
using namespace tfel::math;
// computing DTAU_DDF
this->computeConsistentTangentOperator_DTAU_DDF(smt);
const t2tost2<N,stress> tangentOperator_DTAU_DDF = this->Dt.template get<t2tost2<N,stress> >();
const auto tangentOperator_DTAU_DF = convert<DTAU_DF,DTAU_DDF>(tangentOperator_DTAU_DDF,this->F0,this->F1,this->sig);
const auto tangentOperator_SPATIAL_MODULI = convert<SPATIAL_MODULI,DTAU_DF>(tangentOperator_DTAU_DF,this->F0,this->F1,this->sig);
const auto tangentOperator_DS_DEGL = convert<DS_DEGL,SPATIAL_MODULI>(tangentOperator_SPATIAL_MODULI,this->F0,this->F1,this->sig);
this->Dt = convert<DS_DF,DS_DEGL>(tangentOperator_DS_DEGL,this->F0,this->F1,this->sig);
return true;
}

bool computeConsistentTangentOperator_DS_DDF(const SMType){
tfel::raise("CrystalPlasticityDislocationUpdate::computeConsistentTangentOperator_DS_DDF: "
"computing the tangent operator 'DS_DDF' is not supported");
}

bool computeConsistentTangentOperator_DS_DC(const SMType smt){
using namespace tfel::math;
// computing DTAU_DDF
this->computeConsistentTangentOperator_DTAU_DDF(smt);
const t2tost2<N,stress> tangentOperator_DTAU_DDF = this->Dt.template get<t2tost2<N,stress> >();
const auto tangentOperator_DTAU_DF = convert<DTAU_DF,DTAU_DDF>(tangentOperator_DTAU_DDF,this->F0,this->F1,this->sig);
const auto tangentOperator_SPATIAL_MODULI = convert<SPATIAL_MODULI,DTAU_DF>(tangentOperator_DTAU_DF,this->F0,this->F1,this->sig);
const auto tangentOperator_DS_DEGL = convert<DS_DEGL,SPATIAL_MODULI>(tangentOperator_SPATIAL_MODULI,this->F0,this->F1,this->sig);
this->Dt = convert<DS_DC,DS_DEGL>(tangentOperator_DS_DEGL,this->F0,this->F1,this->sig);
return true;
}

bool computeConsistentTangentOperator_DS_DEGL(const SMType smt){
using namespace tfel::math;
// computing DTAU_DDF
this->computeConsistentTangentOperator_DTAU_DDF(smt);
const t2tost2<N,stress> tangentOperator_DTAU_DDF = this->Dt.template get<t2tost2<N,stress> >();
const auto tangentOperator_DTAU_DF = convert<DTAU_DF,DTAU_DDF>(tangentOperator_DTAU_DDF,this->F0,this->F1,this->sig);
const auto tangentOperator_SPATIAL_MODULI = convert<SPATIAL_MODULI,DTAU_DF>(tangentOperator_DTAU_DF,this->F0,this->F1,this->sig);
this->Dt = convert<DS_DEGL,SPATIAL_MODULI>(tangentOperator_SPATIAL_MODULI,this->F0,this->F1,this->sig);
return true;
}

bool computeConsistentTangentOperator_DT_DELOG(const SMType){
tfel::raise("CrystalPlasticityDislocationUpdate::computeConsistentTangentOperator_DT_DELOG: "
"computing the tangent operator 'DT_DELOG' is not supported");
}

bool computeConsistentTangentOperator_DPK1_DF(const SMType smt){
using namespace tfel::math;
// computing DTAU_DDF
this->computeConsistentTangentOperator_DTAU_DDF(smt);
const t2tost2<N,stress> tangentOperator_DTAU_DDF = this->Dt.template get<t2tost2<N,stress> >();
const auto tangentOperator_DTAU_DF = convert<DTAU_DF,DTAU_DDF>(tangentOperator_DTAU_DDF,this->F0,this->F1,this->sig);
const auto tangentOperator_DSIG_DF = convert<DSIG_DF,DTAU_DF>(tangentOperator_DTAU_DF,this->F0,this->F1,this->sig);
this->Dt = convert<DPK1_DF,DSIG_DF>(tangentOperator_DSIG_DF,this->F0,this->F1,this->sig);
return true;
}

bool computeConsistentTangentOperator(const SMFlag smflag,const SMType smt){
switch(smflag){
case DSIG_DF:
return this->computeConsistentTangentOperator_DSIG_DF(smt);
case DSIG_DDF:
return this->computeConsistentTangentOperator_DSIG_DDF(smt);
case C_TRUESDELL:
return this->computeConsistentTangentOperator_C_TRUESDELL(smt);
case SPATIAL_MODULI:
return this->computeConsistentTangentOperator_SPATIAL_MODULI(smt);
case C_TAU_JAUMANN:
return this->computeConsistentTangentOperator_C_TAU_JAUMANN(smt);
case ABAQUS:
return this->computeConsistentTangentOperator_ABAQUS(smt);
case DSIG_DDE:
return this->computeConsistentTangentOperator_DSIG_DDE(smt);
case DTAU_DF:
return this->computeConsistentTangentOperator_DTAU_DF(smt);
case DTAU_DDF:
return this->computeConsistentTangentOperator_DTAU_DDF(smt);
case DS_DF:
return this->computeConsistentTangentOperator_DS_DF(smt);
case DS_DDF:
return this->computeConsistentTangentOperator_DS_DDF(smt);
case DS_DC:
return this->computeConsistentTangentOperator_DS_DC(smt);
case DS_DEGL:
return this->computeConsistentTangentOperator_DS_DEGL(smt);
case DT_DELOG:
return this->computeConsistentTangentOperator_DT_DELOG(smt);
case DPK1_DF:
return this->computeConsistentTangentOperator_DPK1_DF(smt);
}
tfel::raise("CrystalPlasticityDislocationUpdate::computeConsistentTangentOperator: "
"unsupported tangent operator flag");
}

const TangentOperator& getTangentOperator() const{
return this->Dt;
}

void updateExternalStateVariables(){
this->F0  = this->F1;
this->T += this->dT;
}

//!
~CrystalPlasticityDislocationUpdate()
 override = default;

private:

std::pair<bool,real> computeAPrioriTimeStepScalingFactorII() const{
return {true,this->maximal_time_step_scaling_factor};
}

std::pair<bool,real> computeAPosterioriTimeStepScalingFactorII() const{
return {true,this->maximal_time_step_scaling_factor};
}

//! policy for treating out of bounds conditions
OutOfBoundsPolicy policy = None;
}; // end of CrystalPlasticityDislocationUpdate class

template<typename Type>
std::ostream&
operator <<(std::ostream& os,const CrystalPlasticityDislocationUpdate<ModellingHypothesis::TRIDIMENSIONAL,Type,false>& b)
{
os << "F₀ : " << b.F0 << '\n';
os << "F₁ : " << b.F1 << '\n';
os << "σ : " << b.sig << '\n';
os << "Δt : " << b.dt << '\n';
os << "g : " << b.g << '\n';
os << "Δg : " << b.dg << '\n';
os << "Fe : " << b.Fe << '\n';
os << "p : " << b.p << '\n';
os << "delta_rho_ssd : " << b.delta_rho_ssd << '\n';
os << "T : " << b.T << '\n';
os << "ΔT : " << b.dT << '\n';
os << "D : " << b.D << '\n';
os << "D_tdt : " << b.D_tdt << '\n';
os << "ε : " << b.epsilon << '\n';
os << "θ : " << b.theta << '\n';
os << "young1 : " << b.young1 << '\n';
os << "young2 : " << b.young2 << '\n';
os << "young3 : " << b.young3 << '\n';
os << "nu12 : " << b.nu12 << '\n';
os << "nu23 : " << b.nu23 << '\n';
os << "nu13 : " << b.nu13 << '\n';
os << "mu12 : " << b.mu12 << '\n';
os << "mu23 : " << b.mu23 << '\n';
os << "mu13 : " << b.mu13 << '\n';
os << "ao : " << b.ao << '\n';
os << "xm : " << b.xm << '\n';
os << "creep_ao : " << b.creep_ao << '\n';
os << "creep_xm : " << b.creep_xm << '\n';
os << "burgers_vector_mag : " << b.burgers_vector_mag << '\n';
os << "shear_modulus : " << b.shear_modulus << '\n';
os << "alpha_0 : " << b.alpha_0 << '\n';
os << "r : " << b.r << '\n';
os << "tau_c_0 : " << b.tau_c_0 << '\n';
os << "k_0 : " << b.k_0 << '\n';
os << "y_c : " << b.y_c << '\n';
os << "h : " << b.h << '\n';
os << "h_D : " << b.h_D << '\n';
os << "init_rho_ssd : " << b.init_rho_ssd << '\n';
os << "minimal_time_step_scaling_factor : " << b.minimal_time_step_scaling_factor << '\n';
os << "maximal_time_step_scaling_factor : " << b.maximal_time_step_scaling_factor << '\n';
os << "numerical_jacobian_epsilon : " << b.numerical_jacobian_epsilon << '\n';
os << "iterMax : " << b.iterMax << '\n';
return os;
}

/*!
* Partial specialisation for CrystalPlasticityDislocationUpdate.
*/
template<ModellingHypothesis::Hypothesis hypothesis,typename Type>
class MechanicalBehaviourTraits<CrystalPlasticityDislocationUpdate<hypothesis,Type,false> >
{
public:
static constexpr bool is_defined = false;
static constexpr bool use_quantities = false;
//! orthotropic axes convention
static constexpr OrthotropicAxesConvention oac = OrthotropicAxesConvention::DEFAULT;
static constexpr bool hasStressFreeExpansion = false;
static constexpr bool handlesThermalExpansion = false;
static constexpr unsigned short dimension = 0u;
typedef Type NumType;
static constexpr unsigned short material_properties_nb = 0;
static constexpr unsigned short internal_variables_nb  = 0;
static constexpr unsigned short external_variables_nb  = 0;
static constexpr unsigned short external_variables_nb2 = 0;
static constexpr bool hasConsistentTangentOperator = false;
static constexpr bool isConsistentTangentOperatorSymmetric = false;
static constexpr bool hasPredictionOperator = false;
static constexpr bool hasAPrioriTimeStepScalingFactor = false;
static constexpr bool hasComputeInternalEnergy = false;
static constexpr bool hasComputeDissipatedEnergy = false;
/*!
* \return the name of the class.
*/
static const char* getName(){
return "CrystalPlasticityDislocationUpdate";
}

};

/*!
* Partial specialisation for CrystalPlasticityDislocationUpdate.
*/
template<typename Type>
class MechanicalBehaviourTraits<CrystalPlasticityDislocationUpdate<ModellingHypothesis::TRIDIMENSIONAL,Type,false> >
{
static constexpr unsigned short N = ModellingHypothesisToSpaceDimension<ModellingHypothesis::TRIDIMENSIONAL>::value;
static constexpr unsigned short TVectorSize = N;
typedef tfel::math::StensorDimeToSize<N> StensorDimeToSize;
static constexpr unsigned short StensorSize = StensorDimeToSize::value;
typedef tfel::math::TensorDimeToSize<N> TensorDimeToSize;
static constexpr unsigned short TensorSize = TensorDimeToSize::value;
public:
static constexpr bool is_defined = true;
static constexpr bool use_quantities = false;
//! orthotropic axes convention
static constexpr OrthotropicAxesConvention oac = OrthotropicAxesConvention::DEFAULT;
static constexpr bool hasStressFreeExpansion = false;
static constexpr bool handlesThermalExpansion = false;
static constexpr unsigned short dimension = N;
typedef Type NumType;
static constexpr unsigned short material_properties_nb = 0;
static constexpr unsigned short internal_variables_nb  = 36+TensorSize;
static constexpr unsigned short external_variables_nb  = 1;
static constexpr unsigned short external_variables_nb2 = 0;
static constexpr bool hasConsistentTangentOperator = true;
static constexpr bool isConsistentTangentOperatorSymmetric = false;
static constexpr bool hasPredictionOperator = false;
static constexpr bool hasAPrioriTimeStepScalingFactor = false;
static constexpr bool hasComputeInternalEnergy = false;
static constexpr bool hasComputeDissipatedEnergy = false;
/*!
* \return the name of the class.
*/
static const char* getName(){
return "CrystalPlasticityDislocationUpdate";
}

};

} // end of namespace material

} // end of namespace tfel

#endif /* LIB_TFELMATERIAL_CRYSTALPLASTICITYDISLOCATIONUPDATE_HXX */
