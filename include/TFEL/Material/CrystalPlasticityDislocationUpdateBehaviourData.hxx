/*!
* \file   TFEL/Material/CrystalPlasticityDislocationUpdateBehaviourData.hxx
* \brief  this file implements the CrystalPlasticityDislocationUpdateBehaviourData class.
*         File generated by tfel version 3.4.0
* \author Nicolò Grilli
* \date   17 / 08 / 2023
 */

#ifndef LIB_TFELMATERIAL_CRYSTALPLASTICITYDISLOCATIONUPDATE_BEHAVIOUR_DATA_HXX
#define LIB_TFELMATERIAL_CRYSTALPLASTICITYDISLOCATIONUPDATE_BEHAVIOUR_DATA_HXX

#include<limits>
#include<string>
#include<sstream>
#include<iostream>
#include<stdexcept>
#include<algorithm>

#include"TFEL/Raise.hxx"
#include"TFEL/PhysicalConstants.hxx"
#include"TFEL/Config/TFELConfig.hxx"
#include"TFEL/Config/TFELTypes.hxx"
#include"TFEL/Metaprogramming/StaticAssert.hxx"
#include"TFEL/TypeTraits/IsFundamentalNumericType.hxx"
#include"TFEL/TypeTraits/IsReal.hxx"
#include"TFEL/Math/General/IEEE754.hxx"
#include"TFEL/Math/tvector.hxx"
#include"TFEL/Math/Vector/tvectorIO.hxx"
#include"TFEL/Math/stensor.hxx"
#include"TFEL/Math/Stensor/StensorView.hxx"
#include"TFEL/Math/Stensor/StensorConceptIO.hxx"
#include"TFEL/Math/tmatrix.hxx"
#include"TFEL/Math/Matrix/tmatrixIO.hxx"
#include"TFEL/Math/st2tost2.hxx"
#include"TFEL/Math/ST2toST2/ST2toST2ConceptIO.hxx"
#include"TFEL/Math/ST2toST2/ST2toST2View.hxx"
#include"TFEL/Math/tensor.hxx"
#include"TFEL/Math/Tensor/TensorConceptIO.hxx"
#include"TFEL/Math/t2tot2.hxx"
#include"TFEL/Math/T2toT2/T2toT2ConceptIO.hxx"
#include"TFEL/Math/t2tost2.hxx"
#include"TFEL/Math/T2toST2/T2toST2ConceptIO.hxx"
#include"TFEL/Math/st2tot2.hxx"
#include"TFEL/Math/ST2toT2/ST2toT2ConceptIO.hxx"
#include"TFEL/Math/ST2toST2/ConvertToTangentModuli.hxx"
#include"TFEL/Math/ST2toST2/ConvertSpatialModuliToKirchhoffJaumanRateModuli.hxx"
#include"TFEL/Material/FiniteStrainBehaviourTangentOperator.hxx"
#include"TFEL/Material/ModellingHypothesis.hxx"

#include"TFEL/Math/General/CubicRoots.hxx"
#include "TFEL/Material/CrystalPlasticityDislocationUpdateSlipSystems.hxx"

#include"MFront/Aster/Aster.hxx"

namespace tfel{

namespace material{

//! \brief forward declaration
template<ModellingHypothesis::Hypothesis hypothesis,typename,bool>
class CrystalPlasticityDislocationUpdateBehaviourData;

//! \brief forward declaration
template<ModellingHypothesis::Hypothesis hypothesis,typename Type,bool use_qt>
class CrystalPlasticityDislocationUpdateIntegrationData;

//! \brief forward declaration
template<ModellingHypothesis::Hypothesis hypothesis,typename Type>
std::ostream&
 operator <<(std::ostream&,const CrystalPlasticityDislocationUpdateBehaviourData<hypothesis,Type,false>&);

//! \brief forward declaration
template<typename Type>
std::ostream&
 operator <<(std::ostream&,const CrystalPlasticityDislocationUpdateBehaviourData<ModellingHypothesis::TRIDIMENSIONAL,Type,false>&);

template<typename Type>
class CrystalPlasticityDislocationUpdateBehaviourData<ModellingHypothesis::TRIDIMENSIONAL,Type,false>
{

static constexpr ModellingHypothesis::Hypothesis hypothesis = ModellingHypothesis::TRIDIMENSIONAL;
static constexpr unsigned short N = ModellingHypothesisToSpaceDimension<hypothesis>::value;
TFEL_STATIC_ASSERT(N==1||N==2||N==3);
TFEL_STATIC_ASSERT(tfel::typetraits::IsFundamentalNumericType<Type>::cond);
TFEL_STATIC_ASSERT(tfel::typetraits::IsReal<Type>::cond);

friend std::ostream& operator<< <>(std::ostream&,const CrystalPlasticityDislocationUpdateBehaviourData&);

/* integration data is declared friend to access   driving variables at the beginning of the time step */
friend class CrystalPlasticityDislocationUpdateIntegrationData<hypothesis,Type,false>;

static constexpr unsigned short TVectorSize = N;
typedef tfel::math::StensorDimeToSize<N> StensorDimeToSize;
static constexpr unsigned short StensorSize = StensorDimeToSize::value;
typedef tfel::math::TensorDimeToSize<N> TensorDimeToSize;
static constexpr unsigned short TensorSize = TensorDimeToSize::value;

using ushort =  unsigned short;
using Types = tfel::config::Types<N,Type,false>;
using real                = typename Types::real;
using time                = typename Types::time;
using length              = typename Types::length;
using frequency           = typename Types::frequency;
using stress              = typename Types::stress;
using strain              = typename Types::strain;
using strainrate          = typename Types::strainrate;
using stressrate          = typename Types::stressrate;
using temperature         = typename Types::temperature;
using thermalexpansion    = typename Types::thermalexpansion;
using thermalconductivity = typename Types::thermalconductivity;
using massdensity         = typename Types::massdensity;
using energydensity         = typename Types::energydensity;
using TVector             = typename Types::TVector;
using Stensor             = typename Types::Stensor;
using Stensor4            = typename Types::Stensor4;
using FrequencyStensor    = typename Types::FrequencyStensor;
using ForceTVector        = typename Types::ForceTVector;
using StressStensor       = typename Types::StressStensor;
using StressRateStensor   = typename Types::StressRateStensor;
using DisplacementTVector = typename Types::DisplacementTVector;
using StrainStensor       = typename Types::StrainStensor;
using StrainRateStensor   = typename Types::StrainRateStensor;
using StiffnessTensor     = typename Types::StiffnessTensor;
using Tensor              = typename Types::Tensor;
using FrequencyTensor     = typename Types::FrequencyTensor;
using StressTensor        = typename Types::StressTensor;
using ThermalExpansionCoefficientTensor = typename Types::ThermalExpansionCoefficientTensor;
using DeformationGradientTensor         = typename Types::DeformationGradientTensor;
using DeformationGradientRateTensor     = typename Types::DeformationGradientRateTensor;
using TemperatureGradient = typename Types::TemperatureGradient;
using HeatFlux = typename Types::HeatFlux;
using TangentOperator   = FiniteStrainBehaviourTangentOperator<N,stress>;
using PhysicalConstants = tfel::PhysicalConstants<real>;

protected:

DeformationGradientTensor F0;

StressStensor sig;


tfel::math::tvector<12, strain > g;
DeformationGradientTensor Fe;
#line 58 "CrystalPlasticityDislocationUpdate.mfront"
tfel::math::tvector<12, strain > p;
#line 62 "CrystalPlasticityDislocationUpdate.mfront"
tfel::math::tvector<12, strain > rho_ssd;
temperature T;

public:

/*!
* \brief Default constructor
*/
CrystalPlasticityDislocationUpdateBehaviourData()
{}

/*!
* \brief copy constructor
*/
CrystalPlasticityDislocationUpdateBehaviourData(const CrystalPlasticityDislocationUpdateBehaviourData& src)
: F0(src.F0),
sig(src.sig),
g(src.g),
Fe(src.Fe),
p(src.p),
rho_ssd(src.rho_ssd),
T(src.T)
{}

/*
 * \brief constructor for the Aster interface
 * \param[in] ASTERT_: temperature
 * \param[in] ASTERmat: material properties
 * \param[in] ASTERint_vars: state variables
 * \param[in] ASTERext_vars: external std::ate variables
 */
CrystalPlasticityDislocationUpdateBehaviourData(const Type* const ASTERT_,const Type* const,
const Type* const ASTERint_vars
,const Type* const)
: Fe(&ASTERint_vars[12]),
T(*ASTERT_)
{
g[0] = ASTERint_vars[0];
g[1] = ASTERint_vars[1];
g[2] = ASTERint_vars[2];
g[3] = ASTERint_vars[3];
g[4] = ASTERint_vars[4];
g[5] = ASTERint_vars[5];
g[6] = ASTERint_vars[6];
g[7] = ASTERint_vars[7];
g[8] = ASTERint_vars[8];
g[9] = ASTERint_vars[9];
g[10] = ASTERint_vars[10];
g[11] = ASTERint_vars[11];
p[0] = ASTERint_vars[12+TensorSize];
p[1] = ASTERint_vars[13+TensorSize];
p[2] = ASTERint_vars[14+TensorSize];
p[3] = ASTERint_vars[15+TensorSize];
p[4] = ASTERint_vars[16+TensorSize];
p[5] = ASTERint_vars[17+TensorSize];
p[6] = ASTERint_vars[18+TensorSize];
p[7] = ASTERint_vars[19+TensorSize];
p[8] = ASTERint_vars[20+TensorSize];
p[9] = ASTERint_vars[21+TensorSize];
p[10] = ASTERint_vars[22+TensorSize];
p[11] = ASTERint_vars[23+TensorSize];
rho_ssd[0] = ASTERint_vars[24+TensorSize];
rho_ssd[1] = ASTERint_vars[25+TensorSize];
rho_ssd[2] = ASTERint_vars[26+TensorSize];
rho_ssd[3] = ASTERint_vars[27+TensorSize];
rho_ssd[4] = ASTERint_vars[28+TensorSize];
rho_ssd[5] = ASTERint_vars[29+TensorSize];
rho_ssd[6] = ASTERint_vars[30+TensorSize];
rho_ssd[7] = ASTERint_vars[31+TensorSize];
rho_ssd[8] = ASTERint_vars[32+TensorSize];
rho_ssd[9] = ASTERint_vars[33+TensorSize];
rho_ssd[10] = ASTERint_vars[34+TensorSize];
rho_ssd[11] = ASTERint_vars[35+TensorSize];
}

void setASTERBehaviourDataGradients(const Type* const ASTERstran)
{
DeformationGradientTensor::buildFromFortranMatrix(this->F0,ASTERstran);
}

void setASTERBehaviourDataThermodynamicForces(const Type* const ASTERstress_)
{
this->sig.importTab(ASTERstress_);
}


/*
* \brief Assignement operator
*/
CrystalPlasticityDislocationUpdateBehaviourData&
operator=(const CrystalPlasticityDislocationUpdateBehaviourData& src){
this->F0 = src.F0;
this->sig = src.sig;
this->g = src.g;
this->Fe = src.Fe;
this->p = src.p;
this->rho_ssd = src.rho_ssd;
this->T = src.T;
return *this;
}

void
ASTERexportStateData(Type * const ASTERstress_,Type * const ASTERstatev) const
{
using namespace tfel::math;
this->sig.exportTab(ASTERstress_);
ASTERstatev[0] = this->g[0];
ASTERstatev[1] = this->g[1];
ASTERstatev[2] = this->g[2];
ASTERstatev[3] = this->g[3];
ASTERstatev[4] = this->g[4];
ASTERstatev[5] = this->g[5];
ASTERstatev[6] = this->g[6];
ASTERstatev[7] = this->g[7];
ASTERstatev[8] = this->g[8];
ASTERstatev[9] = this->g[9];
ASTERstatev[10] = this->g[10];
ASTERstatev[11] = this->g[11];
exportToBaseTypeArray(this->Fe,&ASTERstatev[12]);
ASTERstatev[12+TensorSize] = this->p[0];
ASTERstatev[13+TensorSize] = this->p[1];
ASTERstatev[14+TensorSize] = this->p[2];
ASTERstatev[15+TensorSize] = this->p[3];
ASTERstatev[16+TensorSize] = this->p[4];
ASTERstatev[17+TensorSize] = this->p[5];
ASTERstatev[18+TensorSize] = this->p[6];
ASTERstatev[19+TensorSize] = this->p[7];
ASTERstatev[20+TensorSize] = this->p[8];
ASTERstatev[21+TensorSize] = this->p[9];
ASTERstatev[22+TensorSize] = this->p[10];
ASTERstatev[23+TensorSize] = this->p[11];
ASTERstatev[24+TensorSize] = this->rho_ssd[0];
ASTERstatev[25+TensorSize] = this->rho_ssd[1];
ASTERstatev[26+TensorSize] = this->rho_ssd[2];
ASTERstatev[27+TensorSize] = this->rho_ssd[3];
ASTERstatev[28+TensorSize] = this->rho_ssd[4];
ASTERstatev[29+TensorSize] = this->rho_ssd[5];
ASTERstatev[30+TensorSize] = this->rho_ssd[6];
ASTERstatev[31+TensorSize] = this->rho_ssd[7];
ASTERstatev[32+TensorSize] = this->rho_ssd[8];
ASTERstatev[33+TensorSize] = this->rho_ssd[9];
ASTERstatev[34+TensorSize] = this->rho_ssd[10];
ASTERstatev[35+TensorSize] = this->rho_ssd[11];
} // end of ASTERexportStateData

}; // end of CrystalPlasticityDislocationUpdateBehaviourDataclass

template<typename Type>
std::ostream&
operator <<(std::ostream& os,const CrystalPlasticityDislocationUpdateBehaviourData<ModellingHypothesis::TRIDIMENSIONAL,Type,false>& b)
{
os << "F₀ : " << b.F0 << '\n';
os << "σ : " << b.sig << '\n';
os << "g : " << b.g << '\n';
os << "Fe : " << b.Fe << '\n';
os << "p : " << b.p << '\n';
os << "rho_ssd : " << b.rho_ssd << '\n';
os << "T : " << b.T << '\n';
return os;
}

} // end of namespace material

} // end of namespace tfel

#endif /* LIB_TFELMATERIAL_CRYSTALPLASTICITYDISLOCATIONUPDATE_BEHAVIOUR_DATA_HXX */
